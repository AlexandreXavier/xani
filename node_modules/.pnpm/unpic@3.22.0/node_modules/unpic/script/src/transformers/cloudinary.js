"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transform = exports.generate = exports.parse = void 0;
const utils_js_1 = require("../utils.js");
// Thanks Colby!
const cloudinaryRegex = /https?:\/\/(?<host>[^\/]+)\/(?<cloudName>[^\/]+)\/(?<assetType>image|video|raw)\/(?<deliveryType>upload|fetch|private|authenticated|sprite|facebook|twitter|youtube|vimeo)\/?(?<signature>s\-\-[a-zA-Z0-9]+\-\-)?\/?(?<transformations>(?:[^_\/]+_[^,\/]+,?)*)?\/(?:(?<version>v\d+)\/)?(?<idAndFormat>[^\s]+)$/g;
const parseTransforms = (transformations) => {
    return transformations
        ? Object.fromEntries(transformations.split(",").map((t) => t.split("_")))
        : {};
};
const formatUrl = ({ host, cloudName, assetType, deliveryType, signature, transformations = {}, version, id, format, }) => {
    if (format) {
        transformations.f = format;
    }
    const transformString = Object.entries(transformations).map(([key, value]) => `${key}_${value}`).join(",");
    const pathSegments = [
        host,
        cloudName,
        assetType,
        deliveryType,
        signature,
        transformString,
        version,
        id,
    ].filter(Boolean).join("/");
    return `https://${pathSegments}`;
};
const parse = (imageUrl) => {
    const url = (0, utils_js_1.toUrl)(imageUrl);
    const matches = [...url.toString().matchAll(cloudinaryRegex)];
    if (!matches.length) {
        throw new Error("Invalid Cloudinary URL");
    }
    const group = matches[0].groups || {};
    const { transformations: transformString = "", idAndFormat, ...baseParams } = group;
    delete group.idAndFormat;
    const lastDotIndex = idAndFormat.lastIndexOf(".");
    const id = lastDotIndex < 0
        ? idAndFormat
        : idAndFormat.slice(0, lastDotIndex);
    const originalFormat = lastDotIndex < 0
        ? undefined
        : idAndFormat.slice(lastDotIndex + 1);
    const { w, h, f, ...transformations } = parseTransforms(transformString);
    const format = (f && f !== "auto") ? f : originalFormat;
    const base = formatUrl({ ...baseParams, id, transformations });
    return {
        base,
        width: Number(w) || undefined,
        height: Number(h) || undefined,
        format,
        cdn: "cloudinary",
        params: {
            ...group,
            id: group.deliveryType === "fetch" ? idAndFormat : id,
            format,
            transformations,
        },
    };
};
exports.parse = parse;
const generate = ({ base, width, height, format, params }) => {
    const parsed = (0, exports.parse)(base.toString());
    const props = {
        transformations: {},
        ...parsed.params,
        ...params,
        format: format || "auto",
    };
    if (width) {
        props.transformations.w = (0, utils_js_1.roundIfNumeric)(width).toString();
    }
    if (height) {
        props.transformations.h = (0, utils_js_1.roundIfNumeric)(height).toString();
    }
    // Default crop to fill without upscaling
    props.transformations.c ||= "lfill";
    return formatUrl(props);
};
exports.generate = generate;
const transform = ({ url: originalUrl, width, height, format = "auto" }) => {
    const parsed = (0, exports.parse)(originalUrl);
    if (!parsed) {
        throw new Error("Invalid Cloudinary URL");
    }
    if (parsed.params?.assetType !== "image") {
        throw new Error("Cloudinary transformer only supports images");
    }
    if (parsed.params?.signature) {
        throw new Error("Cloudinary transformer does not support signed URLs");
    }
    const props = {
        ...parsed,
        width,
        height,
        format,
    };
    return (0, exports.generate)(props);
};
exports.transform = transform;
