import { toUrl } from "../utils.js";
const uploadcareRegex = /^https?:\/\/(?<host>[^\/]+)\/(?<uuid>[^\/]+)/g;
/**
 * Taken from uploadcare/blocks
 *
 * @see https://github.com/uploadcare/blocks/blob/87d1048e94f05f99e1da988c86c6362522e9a3c8/utils/cdn-utils.js#L57
 */
export function extractFilename(cdnUrl) {
    const url = new URL(cdnUrl);
    const noOrigin = url.pathname + url.search + url.hash;
    const urlFilenameIdx = noOrigin.lastIndexOf("http");
    const plainFilenameIdx = noOrigin.lastIndexOf("/");
    let filename = "";
    if (urlFilenameIdx >= 0) {
        filename = noOrigin.slice(urlFilenameIdx);
    }
    else if (plainFilenameIdx >= 0) {
        filename = noOrigin.slice(plainFilenameIdx + 1);
    }
    return filename;
}
/**
 * Taken from uploadcare/blocks
 *
 * @see https://github.com/uploadcare/blocks/blob/87d1048e94f05f99e1da988c86c6362522e9a3c8/utils/cdn-utils.js#L131
 */
export function isFileUrl(filename) {
    return filename.startsWith("http");
}
/**
 * Taken from uploadcare/blocks
 *
 * @see https://github.com/uploadcare/blocks/blob/87d1048e94f05f99e1da988c86c6362522e9a3c8/utils/cdn-utils.js#L141
 */
export function splitFileUrl(fileUrl) {
    const url = new URL(fileUrl);
    return {
        pathname: url.origin + url.pathname || "",
        search: url.search || "",
        hash: url.hash || "",
    };
}
/**
 * Taken from uploadcare/blocks
 *
 * @see https://github.com/uploadcare/blocks/blob/87d1048e94f05f99e1da988c86c6362522e9a3c8/utils/cdn-utils.js#L114
 */
export function trimFilename(cdnUrl) {
    const url = new URL(cdnUrl);
    const filename = extractFilename(cdnUrl);
    const filenamePathPart = isFileUrl(filename)
        ? splitFileUrl(filename).pathname
        : filename;
    url.pathname = url.pathname.replace(filenamePathPart, "");
    url.search = "";
    url.hash = "";
    return url.toString();
}
/**
 * Taken from uploadcare/blocks
 *
 * @see https://github.com/uploadcare/blocks/blob/87d1048e94f05f99e1da988c86c6362522e9a3c8/utils/cdn-utils.js#L9C1-L24C3
 */
export const normalizeCdnOperation = (operation) => {
    if (typeof operation !== "string" || !operation) {
        return "";
    }
    let str = operation.trim();
    if (str.startsWith("-/")) {
        str = str.slice(2);
    }
    else if (str.startsWith("/")) {
        str = str.slice(1);
    }
    if (str.endsWith("/")) {
        str = str.slice(0, str.length - 1);
    }
    return str;
};
/**
 * Taken from uploadcare/blocks
 *
 * @see https://github.com/uploadcare/blocks/blob/87d1048e94f05f99e1da988c86c6362522e9a3c8/utils/cdn-utils.js#L93C1-L106C2
 */
export function extractOperations(cdnUrl) {
    const withoutFilename = trimFilename(cdnUrl);
    const url = new URL(withoutFilename);
    const operationsMarker = url.pathname.indexOf("/-/");
    if (operationsMarker === -1) {
        return [];
    }
    const operationsStr = url.pathname.substring(operationsMarker);
    return operationsStr
        .split("/-/")
        .filter(Boolean)
        .map((operation) => normalizeCdnOperation(operation));
}
const parseOperations = (operations) => {
    return operations.length
        ? operations.reduce((acc, operation) => {
            const [key, value] = operation.split("/");
            return {
                ...acc,
                [key]: value,
            };
        }, {})
        : {};
};
const formatUrl = ({ host, uuid, operations = {}, filename, }) => {
    const operationString = Object.entries(operations).map(([key, value]) => `${key}/${value}`).join("/-/");
    const pathSegments = [
        host,
        uuid,
        operationString ? `-/${operationString}` : "",
        filename,
    ].join("/");
    return `https://${pathSegments}`;
};
export const parse = (imageUrl) => {
    const url = toUrl(imageUrl);
    const matchers = [...url.toString().matchAll(uploadcareRegex)];
    if (!matchers.length) {
        throw new Error("Invalid Uploadcare URL");
    }
    const group = matchers[0].groups || {};
    const { ...baseParams } = group;
    const filename = extractFilename(url.toString());
    const { format: f, ...operations } = parseOperations(extractOperations(url.toString()));
    const format = (f && f !== "auto") ? f : "auto";
    const base = formatUrl({
        ...baseParams,
        filename: filename || undefined,
        operations: {
            ...operations,
            format,
        },
    });
    return {
        base,
        cdn: "uploadcare",
        params: {
            ...group,
            filename: filename || undefined,
            operations: {
                ...operations,
                format,
            },
        },
    };
};
export const generate = ({ base, width, height, params, }) => {
    const baseUrl = base.toString();
    const parsed = parse(baseUrl.endsWith("/") ? baseUrl : `${baseUrl}/`);
    const props = {
        operations: {},
        ...parsed.params,
        ...params,
    };
    if (width && height) {
        props.operations = {
            ...props.operations,
            resize: `${width}x${height}`,
        };
    }
    else {
        if (width) {
            props.operations = {
                ...props.operations,
                resize: `${width}x`,
            };
        }
        if (height) {
            props.operations = {
                ...props.operations,
                resize: `x${height}`,
            };
        }
    }
    return formatUrl(props);
};
export const transform = ({ url: originalUrl, width, height, }) => {
    const parsed = parse(originalUrl);
    if (!parsed) {
        throw new Error("Invalid Uploadcare URL");
    }
    const props = {
        ...parsed,
        width,
        height,
    };
    return generate(props);
};
