import path from "node:path";
import { appendForwardSlash } from "@astrojs/internal-helpers/path";
import { invalidateCompilation, isCached } from "../core/compile/index.js";
async function handleHotUpdate(ctx, { config, logger, astroFileToCssAstroDeps, compile, source }) {
  let isStyleOnlyChange = false;
  if (ctx.file.endsWith(".astro") && isCached(config, ctx.file)) {
    const oldResult = await compile();
    if (oldResult.source === source)
      return [];
    invalidateCompilation(config, ctx.file);
    const newResult = await compile();
    if (isStyleOnlyChanged(oldResult, newResult)) {
      isStyleOnlyChange = true;
    }
  } else {
    invalidateCompilation(config, ctx.file);
  }
  if (isStyleOnlyChange) {
    logger.debug("watch", "style-only change");
    return ctx.modules.filter((mod) => mod.id?.includes("astro&type=style"));
  }
  for (const [astroFile, cssAstroDeps] of astroFileToCssAstroDeps) {
    if (cssAstroDeps.has(ctx.file)) {
      logger.info("watch", getShortName(ctx.file, ctx.server.config.root));
      const parentModules = ctx.server.moduleGraph.getModulesByFile(astroFile);
      if (parentModules) {
        for (const mod of parentModules) {
          ctx.server.moduleGraph.invalidateModule(mod);
        }
      }
      ctx.server.ws.send({ type: "full-reload", path: "*" });
    }
  }
}
function isStyleOnlyChanged(oldResult, newResult) {
  return normalizeCode(oldResult.code) === normalizeCode(newResult.code) && // If style tags are added/removed, we need to regenerate the main Astro file
  // so that its CSS imports are also added/removed
  oldResult.css.length === newResult.css.length && !isArrayEqual(oldResult.css, newResult.css);
}
const astroStyleImportRE = /import\s*"[^"]+astro&type=style[^"]+";/g;
const sourceMappingUrlRE = /\/\/# sourceMappingURL=[^ ]+$/gm;
function normalizeCode(code) {
  return code.replace(astroStyleImportRE, "").replace(sourceMappingUrlRE, "").trim();
}
function isArrayEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
function getShortName(file, root) {
  return file.startsWith(appendForwardSlash(root)) ? path.posix.relative(root, file) : file;
}
export {
  handleHotUpdate
};
