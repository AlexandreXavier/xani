import * as url from 'url';
import * as path from 'path';
import * as fs from 'fs/promises';
import { fileTypeFromBuffer } from 'file-type';
import sharp from 'sharp';
import { AllImageFormat } from '../compressors/images.js';
/**
 * File extension, mime and data are loaded only on demand, then cached.
 */
export class Resource {
    constructor(src, filePathAbsolute) {
        this.src = src;
        this.filePathAbsolute = filePathAbsolute;
    }
    async getData() {
        if (this.data === undefined) {
            this.data = await fs.readFile(this.filePathAbsolute);
        }
        return this.data;
    }
    async getImageMeta() {
        if (this.image_meta === undefined) {
            const ext = await this.getExt();
            switch (ext) {
                case 'svg':
                case 'gif':
                case 'jpg':
                case 'png':
                case 'webp':
                case 'tif':
                case 'avif':
                    let sharpFile = await sharp(await this.getData(), { animated: true });
                    const meta = await sharpFile.metadata();
                    this.image_meta = {
                        width: meta.width,
                        height: meta.height,
                        isProgressive: meta.isProgressive || false,
                        hasAlpha: meta.hasAlpha || false,
                    };
                    break;
            }
        }
        if (!this.image_meta) {
            console.log(await this.getExt());
        }
        return this.image_meta;
    }
    async getLen() {
        return (await this.getData()).length;
    }
    async getExt() {
        if (this.ext === undefined) {
            await this.loadFileType();
        }
        return this.ext;
    }
    async getImageFormat() {
        const ext = (await this.getExt());
        if (AllImageFormat.includes(ext))
            return ext;
        return undefined;
    }
    async getMime() {
        if (this.mime === undefined) {
            await this.loadFileType();
        }
        return this.mime;
    }
    async loadFileType() {
        const fileType = await fileTypeFromBuffer(await this.getData());
        if (this.filePathAbsolute.endsWith('.svg')) {
            this.ext = 'svg';
            this.mime = 'image/svg+xml';
        }
        else if (fileType) {
            this.ext = fileType.ext;
            this.mime = fileType.mime;
        }
        else {
            throw new Error(`Unknown file type "${this.src}"`);
        }
    }
    static async loadResource(projectRoot, relativeFile, src) {
        if (!isLocal(src)) {
            throw new Error('src should be local');
        }
        const u = url.parse(src);
        if (!u.pathname) {
            throw new Error(`Invalid src format "${src}"`);
        }
        const relativePath = path.join(projectRoot, src.startsWith('/') ? '' : path.dirname(relativeFile), u.pathname);
        let absolutePath = path.resolve(relativePath);
        if (await fileExists(absolutePath)) {
            return new Resource(src, absolutePath);
        }
        return undefined;
    }
}
export function isLocal(src) {
    const u = url.parse(src);
    return !u.host;
}
export async function fileExists(path) {
    try {
        await fs.stat(path);
    }
    catch (e) {
        return false;
    }
    return true;
}
export function translateSrc(projectRoot, htmlRelativePath, src) {
    if (!isLocal(src)) {
        throw new Error('Source should be local');
    }
    const srcAbsolutePath = path.join(projectRoot, src.startsWith('/') ? '' : htmlRelativePath, src);
    return path.resolve(srcAbsolutePath);
}
